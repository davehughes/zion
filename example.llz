program test_list

type List{int} polymorph {
	/* guarantees that all contained types either are atoms, or contain an atom as their first element */
	Done
	Node{int}
}

type Node{int} struct {
	value int
	next List{int}
}

/* struct type will automatically create a type constructor for the named type */
fn Node{int}(p1 int, p2 List{int}) Node{int} ctor

type int struct {
	raw __int__
}

fn len(l List{int}) int {
	match l {
		Done: {
			const _t1 int = int(0)
			return _t1
		}
		Node{int}: {
			const _t1 = int(1)
			const _t2 = len(l.next)
			const _t3 = __plus__(_t1, _t2)
			return _t3
		}
	}
	/* we can be sure we'll never hit this codepath due to full coverage checks on the pattern match */
}

fn sum(l List{int}) int {
	match l {
		Done: {
			const _t1 = int(0)
			return _t1
		}
		*"Node{int}" {
			const _t1 = l.value
			const _t2 = sum(l.next)
			const _t3 = __plus__(_t1, _t2)
			return _t3
		}
	}
	/* we can be sure we'll never hit this codepath due to full coverage checks on the pattern match */
}

/* SFC - single function call per statement allowed. */
main(argc __int__, argv *__str__) __int__ {
	const _t1 = Done
	const _t2 = int(3)
	const _t3 = Node{int}(_t2, _t1)
	const _t4 = int(2)
	const _t5 = Node{int}(_t4, _t3)
	const _t6 = int(1)
	const _t7 = Node{int}(_t6, _t5)

	var l = _t7
	const _t8 = len(l)
	print(_t8)
	const _t9 = sum(l)
	print(_t9)

	/* print the numbers from 0 to 99 */
	var i = 0
	loop {
		const _cond = __lt__(i, 100)
		if _cond {
			print(i)
			const _t10 = __plus__(i, 1)
			i = _t10
		} else {
			break
		}
	}
	return
}
